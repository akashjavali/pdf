'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BELOW = 1;
var INSIDE = 2;
var ABOVE = 3;

var BELOW_TO_INSIDE = BELOW << 4 | INSIDE;
var BELOW_TO_ABOVE = BELOW << 4 | ABOVE;
var INSIDE_TO_BELOW = INSIDE << 4 | BELOW;
var INSIDE_TO_ABOVE = INSIDE << 4 | ABOVE;
var ABOVE_TO_INSIDE = ABOVE << 4 | INSIDE;
var ABOVE_TO_BELOW = ABOVE << 4 | BELOW;

var LEFT = 0;
var RIGHT = 1;

/**
 * A LineFragmentGenerator splits line rectangles into fragments,
 * wrapping inside a container's polygon, and outside its exclusion polygon.
 */

exports.default = function () {
  return function (_ref) {
    var Rect = _ref.Rect;
    return function () {
      function LineFragmentGenerator() {
        _classCallCheck(this, LineFragmentGenerator);
      }

      _createClass(LineFragmentGenerator, [{
        key: 'generateFragments',
        value: function generateFragments(lineRect, container) {
          var rects = this.splitLineRect(lineRect, container.polygon, 'INTERIOR');
          var exclusion = container.exclusionPolygon;

          if (exclusion) {
            var res = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = rects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var rect = _step.value;

                res.push.apply(res, _toConsumableArray(this.splitLineRect(rect, exclusion, 'EXTERIOR')));
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return res;
          }

          return rects;
        }
      }, {
        key: 'splitLineRect',
        value: function splitLineRect(lineRect, polygon, type) {
          var minY = lineRect.y;
          var maxY = lineRect.maxY;
          var markers = [];
          var wrapState = BELOW;
          var min = Infinity;
          var max = -Infinity;

          for (var i = 0; i < polygon.contours.length; i++) {
            var contour = polygon.contours[i];
            var index = -1;
            var state = -1;

            // Find the first point outside the line rect.
            do {
              var point = contour[++index];
              state = point.y <= minY ? BELOW : point.y >= maxY ? ABOVE : INSIDE;
            } while (state === INSIDE && index < contour.length - 1);

            // Contour is entirely inside the line rect. Skip it.
            if (state === INSIDE) {
              continue;
            }

            var dir = type === 'EXTERIOR' ? 1 : -1;
            var idx = type === 'EXTERIOR' ? index : contour.length + index;
            var currentPoint = void 0;

            for (var _index = 0; _index <= contour.length; _index++, idx += dir) {
              var _point = contour[idx % contour.length];

              if (_index === 0) {
                currentPoint = _point;
                state = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;
                continue;
              }

              var s = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;
              var x = _point.x;

              if (s !== state) {
                var stateChangeType = state << 4 | s;
                switch (stateChangeType) {
                  case BELOW_TO_INSIDE:
                    {
                      // console.log('BELOW_TO_INSIDE')
                      var xIntercept = xIntersection(minY, _point, currentPoint);
                      min = Math.min(xIntercept, x);
                      max = Math.max(xIntercept, x);
                      wrapState = BELOW;
                      break;
                    }

                  case BELOW_TO_ABOVE:
                    {
                      // console.log('BELOW_TO_ABOVE')
                      var x1 = xIntersection(minY, _point, currentPoint);
                      var x2 = xIntersection(maxY, _point, currentPoint);
                      markers.push({
                        type: LEFT,
                        position: Math.max(x1, x2)
                      });
                      break;
                    }

                  case ABOVE_TO_INSIDE:
                    {
                      // console.log('ABOVE_TO_INSIDE')
                      var _xIntercept = xIntersection(maxY, _point, currentPoint);
                      min = Math.min(_xIntercept, x);
                      max = Math.max(_xIntercept, x);
                      wrapState = ABOVE;
                      break;
                    }

                  case ABOVE_TO_BELOW:
                    {
                      // console.log('ABOVE_TO_BELOW')
                      var _x = xIntersection(minY, _point, currentPoint);
                      var _x2 = xIntersection(maxY, _point, currentPoint);
                      markers.push({
                        type: RIGHT,
                        position: Math.min(_x, _x2)
                      });
                      break;
                    }

                  case INSIDE_TO_ABOVE:
                    {
                      // console.log('INSIDE_TO_ABOVE')
                      var _x3 = xIntersection(maxY, _point, currentPoint);
                      max = Math.max(max, _x3);

                      markers.push({ type: LEFT, position: max });

                      if (wrapState === ABOVE) {
                        min = Math.min(min, _x3);
                        markers.push({ type: RIGHT, position: min });
                      }

                      break;
                    }

                  case INSIDE_TO_BELOW:
                    {
                      // console.log('INSIDE_TO_BELOW')
                      var _x4 = xIntersection(minY, _point, currentPoint);
                      min = Math.min(min, _x4);

                      markers.push({ type: RIGHT, position: min });

                      if (wrapState === BELOW) {
                        max = Math.max(max, _x4);
                        markers.push({ type: LEFT, position: max });
                      }

                      break;
                    }

                  default:
                    throw new Error('Unknown state change');
                }
                state = s;
              } else if (s === INSIDE) {
                min = Math.min(min, x);
                max = Math.max(max, x);
              }

              currentPoint = _point;
            }
          }

          markers.sort(function (a, b) {
            return a.position - b.position;
          });
          // console.log(markers);

          var G = 0;
          if (type === 'INTERIOR' || markers.length > 0 && markers[0].type === LEFT) {
            G++;
          }

          // console.log(G)

          var minX = lineRect.x;
          var maxX = lineRect.maxX;
          var height = lineRect.height;

          var rects = [];

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = markers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var marker = _step2.value;

              if (marker.type === RIGHT) {
                if (G === 0) {
                  var p = Math.min(maxX, marker.position);
                  if (p >= minX) {
                    rects.push(new Rect(minX, minY, p - minX, height));
                  }
                }

                G++;
              } else {
                G--;
                if (G === 0 && marker.position > minX) {
                  minX = marker.position;
                }
              }
            }

            // console.log(G, maxX, minX)
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (G === 0 && maxX >= minX) {
            rects.push(new Rect(minX, minY, maxX - minX, height));
          }

          // console.log(rects)
          return rects;
        }
      }]);

      return LineFragmentGenerator;
    }();
  };
};

function xIntersection(e, t, n) {
  var r = e - n.y;
  var i = t.y - n.y;

  return r / i * (t.x - n.x) + n.x;
}