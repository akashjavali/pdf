'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A TextRenderer renders text layout objects to a graphics context.
 */
exports.default = function (_ref) {
  var Rect = _ref.Rect;
  return function () {
    function PDFRenderer(ctx) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PDFRenderer);

      this.ctx = ctx;
      this.outlineBlocks = options.outlineBlocks || false;
      this.outlineLines = options.outlineLines || false;
      this.outlineRuns = options.outlineRuns || false;
      this.outlineAttachments = options.outlineAttachments || false;
    }

    _createClass(PDFRenderer, [{
      key: 'render',
      value: function render(container) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = container.blocks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var block = _step.value;

            this.renderBlock(block);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }, {
      key: 'renderBlock',
      value: function renderBlock(block) {
        if (this.outlineBlocks) {
          var _block$bbox = block.bbox,
              minX = _block$bbox.minX,
              minY = _block$bbox.minY,
              width = _block$bbox.width,
              height = _block$bbox.height;

          this.ctx.rect(minX, minY, width, height).stroke();
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = block.lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var line = _step2.value;

            this.renderLine(line);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: 'renderLine',
      value: function renderLine(line) {
        if (this.outlineLines) {
          this.ctx.rect(line.rect.x, line.rect.y, line.rect.width, line.rect.height).stroke();
        }

        this.ctx.save();
        this.ctx.translate(line.rect.x, line.rect.y + line.ascent);

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = line.glyphRuns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var run = _step3.value;

            if (run.attributes.backgroundColor) {
              var backgroundRect = new Rect(0, -line.ascent, run.advanceWidth, line.rect.height);
              this.renderBackground(backgroundRect, run.attributes.backgroundColor);
            }

            this.renderRun(run);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        this.ctx.restore();
        this.ctx.save();
        this.ctx.translate(line.rect.x, line.rect.y);

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = line.decorationLines[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var decorationLine = _step4.value;

            this.renderDecorationLine(decorationLine);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        this.ctx.restore();
      }
    }, {
      key: 'renderRun',
      value: function renderRun(run) {
        var _run$attributes = run.attributes,
            font = _run$attributes.font,
            fontSize = _run$attributes.fontSize,
            color = _run$attributes.color,
            link = _run$attributes.link;


        if (this.outlineRuns) {
          this.ctx.rect(0, 0, run.advanceWidth, run.height).stroke();
        }

        this.ctx.fillColor(color);

        if (link) {
          this.ctx.link(0, -run.height - run.descent, run.advanceWidth, run.height, link);
        }

        this.renderAttachments(run);

        if (font.sbix || font.COLR && font.CPAL) {
          this.ctx.save();
          this.ctx.translate(0, -run.ascent);

          for (var i = 0; i < run.glyphs.length; i++) {
            var position = run.positions[i];
            var glyph = run.glyphs[i];

            this.ctx.save();
            this.ctx.translate(position.xOffset, position.yOffset);

            glyph.render(this.ctx, fontSize);

            this.ctx.restore();
            this.ctx.translate(position.xAdvance, position.yAdvance);
          }

          this.ctx.restore();
        } else {
          this.ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);
          this.ctx._addGlyphs(run.glyphs, run.positions, 0, 0);
        }

        this.ctx.translate(run.advanceWidth, 0);
      }
    }, {
      key: 'renderBackground',
      value: function renderBackground(rect, backgroundColor) {
        this.ctx.rect(rect.x, rect.y, rect.width, rect.height);
        this.ctx.fill(backgroundColor);
      }
    }, {
      key: 'renderAttachments',
      value: function renderAttachments(run) {
        this.ctx.save();

        var font = run.attributes.font;

        var space = font.glyphForCodePoint(0x20);
        var objectReplacement = font.glyphForCodePoint(0xfffc);

        for (var i = 0; i < run.glyphs.length; i++) {
          var position = run.positions[i];
          var glyph = run.glyphs[i];

          this.ctx.translate(position.xAdvance, position.yOffset);

          if (glyph === objectReplacement && run.attributes.attachment) {
            this.renderAttachment(run.attributes.attachment);
            run.glyphs[i] = space;
          }
        }

        this.ctx.restore();
      }
    }, {
      key: 'renderAttachment',
      value: function renderAttachment(attachment) {
        var _attachment$xOffset = attachment.xOffset,
            xOffset = _attachment$xOffset === undefined ? 0 : _attachment$xOffset,
            _attachment$yOffset = attachment.yOffset,
            yOffset = _attachment$yOffset === undefined ? 0 : _attachment$yOffset;


        this.ctx.translate(-attachment.width + xOffset, -attachment.height + yOffset);

        if (this.outlineAttachments) {
          this.ctx.rect(0, 0, attachment.width, attachment.height).stroke();
        }

        if (typeof attachment.render === 'function') {
          this.ctx.rect(0, 0, attachment.width, attachment.height);
          this.ctx.clip();
          attachment.render(this.ctx);
        } else if (attachment.image) {
          this.ctx.image(attachment.image, 0, 0, {
            fit: [attachment.width, attachment.height],
            align: 'center',
            valign: 'bottom'
          });
        }
      }
    }, {
      key: 'renderDecorationLine',
      value: function renderDecorationLine(line) {
        this.ctx.lineWidth(line.rect.height);

        if (/dashed/.test(line.style)) {
          this.ctx.dash(3 * line.rect.height);
        } else if (/dotted/.test(line.style)) {
          this.ctx.dash(line.rect.height);
        }

        if (/wavy/.test(line.style)) {
          var dist = Math.max(2, line.rect.height);
          var step = 1.1 * dist;
          var stepCount = Math.floor(line.rect.width / (2 * step));

          // Adjust step to fill entire width
          var remainingWidth = line.rect.width - stepCount * 2 * step;
          var adjustment = remainingWidth / stepCount / 2;
          step += adjustment;

          var cp1y = line.rect.y + dist;
          var cp2y = line.rect.y - dist;
          var x = line.rect.x;


          this.ctx.moveTo(line.rect.x, line.rect.y);

          for (var i = 0; i < stepCount; i++) {
            this.ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);
            x += 2 * step;
          }
        } else {
          this.ctx.moveTo(line.rect.x, line.rect.y);
          this.ctx.lineTo(line.rect.maxX, line.rect.y);

          if (/double/.test(line.style)) {
            this.ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);
            this.ctx.lineTo(line.rect.maxX, line.rect.y + line.rect.height * 2);
          }
        }

        this.ctx.stroke(line.color);
      }
    }]);

    return PDFRenderer;
  }();
};