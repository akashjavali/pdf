'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linebreak = require('linebreak');

var _linebreak2 = _interopRequireDefault(_linebreak);

var _hypher = require('hypher');

var _hypher2 = _interopRequireDefault(_hypher);

var _hyphenation = require('hyphenation.en-us');

var _hyphenation2 = _interopRequireDefault(_hyphenation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var hyphenator = new _hypher2.default(_hyphenation2.default);
var HYPHEN = 0x002d;
var SHRINK_FACTOR = 0.04;

/**
 * A LineBreaker is used by the Typesetter to perform
 * Unicode line breaking and hyphenation.
 */

exports.default = function () {
  return function () {
    return function () {
      function LineBreaker() {
        _classCallCheck(this, LineBreaker);
      }

      _createClass(LineBreaker, [{
        key: 'suggestLineBreak',
        value: function suggestLineBreak(glyphString, width, paragraphStyle) {
          var hyphenationFactor = paragraphStyle.hyphenationFactor || 0;
          var glyphIndex = glyphString.glyphIndexAtOffset(width);

          if (glyphIndex === -1) return null;

          if (glyphIndex === glyphString.length) {
            return { position: glyphString.length, required: true };
          }

          var stringIndex = glyphString.stringIndexForGlyphIndex(glyphIndex);
          var bk = this.findBreakPreceeding(glyphString.string, stringIndex);

          if (bk) {
            var breakIndex = glyphString.glyphIndexForStringIndex(bk.position);

            if (bk.next != null && this.shouldHyphenate(glyphString, breakIndex, width, hyphenationFactor)) {
              var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);
              var shrunk = lineWidth + lineWidth * SHRINK_FACTOR;

              var shrunkIndex = glyphString.glyphIndexAtOffset(shrunk);
              stringIndex = Math.min(bk.next, glyphString.stringIndexForGlyphIndex(shrunkIndex));

              var point = this.findHyphenationPoint(glyphString.string.slice(bk.position, bk.next), stringIndex - bk.position);

              if (point > 0) {
                bk.position += point;
                breakIndex = glyphString.glyphIndexForStringIndex(bk.position);

                if (bk.position < bk.next) {
                  glyphString.insertGlyph(breakIndex++, HYPHEN);
                }
              }
            }

            bk.position = breakIndex;
          }

          return bk;
        }
      }, {
        key: 'findBreakPreceeding',
        value: function findBreakPreceeding(string, index) {
          var breaker = new _linebreak2.default(string);
          var last = null;
          var bk = null;

          while (bk = breaker.nextBreak()) {
            // console.log(bk);
            if (bk.position > index) {
              if (last) {
                last.next = bk.position;
              }

              return last;
            }

            if (bk.required) {
              return bk;
            }

            last = bk;
          }

          return null;
        }
      }, {
        key: 'shouldHyphenate',
        value: function shouldHyphenate(glyphString, glyphIndex, width, hyphenationFactor) {
          var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);
          return lineWidth / width < hyphenationFactor;
        }
      }, {
        key: 'findHyphenationPoint',
        value: function findHyphenationPoint(string, index) {
          var parts = hyphenator.hyphenate(string);
          var count = 0;

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var part = _step.value;

              if (count + part.length > index) {
                break;
              }

              count += part.length;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return count;
        }
      }]);

      return LineBreaker;
    }();
  };
};