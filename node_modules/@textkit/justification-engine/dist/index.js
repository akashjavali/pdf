'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash.clone');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.merge');

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KASHIDA_PRIORITY = 0;
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var NULL_PRIORITY = 3;

var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};

var EXPAND_CHAR_FACTOR = {
  before: 0.14453125, // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};

var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875, // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};

var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};

/**
 * A JustificationEngine is used by a Typesetter to perform line fragment
 * justification. This implementation is based on a description of Apple's
 * justification algorithm from a PDF in the Apple Font Tools package.
 */

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$expandCharFactor = _ref.expandCharFactor,
      expandCharFactor = _ref$expandCharFactor === undefined ? {} : _ref$expandCharFactor,
      _ref$expandWhitespace = _ref.expandWhitespaceFactor,
      expandWhitespaceFactor = _ref$expandWhitespace === undefined ? {} : _ref$expandWhitespace,
      _ref$shrinkCharFactor = _ref.shrinkCharFactor,
      shrinkCharFactor = _ref$shrinkCharFactor === undefined ? {} : _ref$shrinkCharFactor,
      _ref$shrinkWhitespace = _ref.shrinkWhitespaceFactor,
      shrinkWhitespaceFactor = _ref$shrinkWhitespace === undefined ? {} : _ref$shrinkWhitespace;

  return function () {
    return function () {
      function JustificationEngine() {
        _classCallCheck(this, JustificationEngine);

        this.expandCharFactor = (0, _lodash4.default)(EXPAND_CHAR_FACTOR, expandCharFactor);
        this.expandWhitespaceFactor = (0, _lodash4.default)(EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor);
        this.shrinkCharFactor = (0, _lodash4.default)(SHRINK_CHAR_FACTOR, shrinkCharFactor);
        this.shrinkWhitespaceFactor = (0, _lodash4.default)(SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);
      }

      _createClass(JustificationEngine, [{
        key: 'justify',
        value: function justify(line) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var factor = options.factor || 1;
          if (factor < 0 || factor > 1) {
            throw new Error('Invalid justification factor: ' + factor);
          }

          var gap = line.rect.width - line.advanceWidth;
          if (gap === 0) {
            return;
          }

          var factors = [];
          var start = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = line.glyphRuns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var run = _step.value;

              factors.push.apply(factors, _toConsumableArray(this.factor(line, start, run.glyphs, gap > 0 ? 'GROW' : 'SHRINK')));
              start += run.glyphs.length;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          factors[0].before = 0;
          factors[factors.length - 1].after = 0;

          var distances = this.assign(gap, factors);

          var index = 0;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = line.glyphRuns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _run = _step2.value;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = _run.positions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var position = _step3.value;

                  position.xAdvance += distances[index++];
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: 'factor',
        value: function factor(line, start, glyphs, direction) {
          var charFactor = void 0;
          var whitespaceFactor = void 0;

          if (direction === 'GROW') {
            charFactor = (0, _lodash2.default)(this.expandCharFactor);
            whitespaceFactor = (0, _lodash2.default)(this.expandWhitespaceFactor);
          } else {
            charFactor = (0, _lodash2.default)(this.shrinkCharFactor);
            whitespaceFactor = (0, _lodash2.default)(this.shrinkWhitespaceFactor);
          }

          var factors = [];
          for (var index = 0; index < glyphs.length; index++) {
            var factor = void 0;
            var glyph = glyphs[index];
            if (line.isWhiteSpace(start + index)) {
              factor = (0, _lodash2.default)(whitespaceFactor);

              if (index === glyphs.length - 1) {
                factor.before = 0;

                if (index > 0) {
                  factors[index - 1].after = 0;
                }
              }
            } else if (glyph.isMark && index > 0) {
              factor = (0, _lodash2.default)(factors[index - 1]);
              factor.before = 0;
              factors[index - 1].after = 0;
            } else {
              factor = (0, _lodash2.default)(charFactor);
            }

            factors.push(factor);
          }

          return factors;
        }
      }, {
        key: 'assign',
        value: function assign(gap, factors) {
          var total = 0;
          var priorities = [];
          var unconstrained = [];

          for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority++) {
            priorities[_priority] = unconstrained[_priority] = 0;
          }

          // sum the factors at each priority
          for (var j = 0; j < factors.length; j++) {
            var factor = factors[j];
            var sum = factor.before + factor.after;
            total += sum;
            priorities[factor.priority] += sum;
            if (factor.unconstrained) {
              unconstrained[factor.priority] += sum;
            }
          }

          // choose the priorities that need to be applied
          var highestPriority = -1;
          var highestPrioritySum = 0;
          var remainingGap = gap;
          var priority = void 0;
          for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority++) {
            var prioritySum = priorities[priority];
            if (prioritySum !== 0) {
              if (highestPriority === -1) {
                highestPriority = priority;
                highestPrioritySum = prioritySum;
              }

              // if this priority covers the remaining gap, we're done
              if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
                priorities[priority] = remainingGap / prioritySum;
                unconstrained[priority] = 0;
                remainingGap = 0;
                break;
              }

              // mark that we need to use 100% of the adjustment from
              // this priority, and subtract the space that it consumes
              priorities[priority] = 1;
              remainingGap -= prioritySum;

              // if this priority has unconstrained glyphs, let them consume the remaining space
              if (unconstrained[priority] !== 0) {
                unconstrained[priority] = remainingGap / unconstrained[priority];
                remainingGap = 0;
                break;
              }
            }
          }

          // zero out remaining priorities (if any)
          for (var p = priority + 1; p <= NULL_PRIORITY; p++) {
            priorities[p] = 0;
            unconstrained[p] = 0;
          }

          // if there is still space left over, assign it to the highest priority that we saw.
          // this violates their factors, but it only happens in extreme cases
          if (remainingGap > 0 && highestPriority > -1) {
            priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
          }

          // create and return an array of distances to add to each glyph's advance
          var distances = [];
          for (var index = 0; index < factors.length; index++) {
            // the distance to add to this glyph is the sum of the space to add
            // after this glyph, and the space to add before the next glyph
            var _factor = factors[index];
            var next = factors[index + 1];
            var dist = _factor.after * priorities[_factor.priority];

            if (next) {
              dist += next.before * priorities[next.priority];
            }

            // if this glyph is unconstrained, add the unconstrained distance as well
            if (_factor.unconstrained) {
              dist += _factor.after * unconstrained[_factor.priority];
              if (next) {
                dist += next.before * unconstrained[next.priority];
              }
            }

            distances.push(dist);
          }

          return distances;
        }
      }, {
        key: 'postprocess',
        value: function postprocess() {
          // do nothing by default
          return false;
        }
      }]);

      return JustificationEngine;
    }();
  };
};