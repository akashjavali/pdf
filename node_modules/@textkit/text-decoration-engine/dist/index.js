'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A TextDecorationEngine is used by a Typesetter to generate
 * DecorationLines for a line fragment, including underlines
 * and strikes.
 */

exports.default = function () {
  return function (_ref) {
    var Rect = _ref.Rect,
        Range = _ref.Range,
        DecorationLine = _ref.DecorationLine;

    // The base font size used for calculating underline thickness.
    var BASE_FONT_SIZE = 16;

    return function () {
      function TextDecorationEngine() {
        _classCallCheck(this, TextDecorationEngine);
      }

      _createClass(TextDecorationEngine, [{
        key: 'createDecorationLines',
        value: function createDecorationLines(lineFragment) {
          // Create initial underline and strikethrough lines
          var x = lineFragment.overflowLeft;
          var maxX = lineFragment.advanceWidth - lineFragment.overflowRight;
          var underlines = [];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = lineFragment.glyphRuns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var run = _step.value;

              var width = Math.min(maxX - x, run.advanceWidth);
              var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));

              if (run.attributes.underline) {
                var rect = new Rect(x, lineFragment.ascent, width, thickness);
                var line = new DecorationLine(rect, run.attributes.underlineColor, run.attributes.underlineStyle);
                this.addDecorationLine(line, underlines);
              }

              if (run.attributes.strike) {
                var y = lineFragment.ascent - run.ascent / 3;
                var _rect = new Rect(x, y, width, thickness);
                var _line = new DecorationLine(_rect, run.attributes.strikeColor, run.attributes.strikeStyle);
                this.addDecorationLine(_line, lineFragment.decorationLines);
              }

              x += width;
            }

            // Adjust underline y positions, and intersect with glyph descenders.
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = underlines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _lineFragment$decorat;

              var _line2 = _step2.value;

              _line2.rect.y += _line2.rect.height * 2;
              (_lineFragment$decorat = lineFragment.decorationLines).push.apply(_lineFragment$decorat, _toConsumableArray(this.intersectWithGlyphs(_line2, lineFragment)));
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: 'addDecorationLine',
        value: function addDecorationLine(line, lines) {
          var last = lines[lines.length - 1];
          if (!last || !last.merge(line)) {
            lines.push(line);
          }
        }

        /**
         * Computes the intersections between an underline and the glyphs in
         * a line fragment. Returns an array of DecorationLines omitting the
         * intersections.
         */

      }, {
        key: 'intersectWithGlyphs',
        value: function intersectWithGlyphs(line, lineFragment) {
          // Find intersection ranges between underline and glyphs
          var x = 0;
          var y = lineFragment.ascent;
          var ranges = [];

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = lineFragment.glyphRuns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var run = _step3.value;

              if (!run.attributes.underline) {
                x += run.advanceWidth;
                continue;
              }

              for (var i = 0; i < run.glyphs.length; i++) {
                var position = run.positions[i];

                if (x >= line.rect.x && x <= line.rect.maxX) {
                  var gx = x + position.xOffset;
                  var gy = y + position.yOffset;

                  // Standard fonts may not have a path to intersect with
                  if (run.glyphs[i].path) {
                    var path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);
                    var range = this.findPathIntersections(path, line.rect);

                    if (range) {
                      ranges.push(range);
                    }
                  }
                }

                x += position.xAdvance;
                y += position.yAdvance;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          if (ranges.length === 0) {
            // No intersections. Return the original line.
            return [line];
          }

          var merged = Range.merge(ranges);

          // Generate underline segments omitting the intersections,
          // but only if the space warrents an underline.
          var lines = [];
          x = line.rect.x;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = merged[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _ref3 = _step4.value;
              var start = _ref3.start,
                  end = _ref3.end;

              if (start - x > line.rect.height) {
                lines.push(line.slice(x, start));
              }

              x = end;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          if (line.rect.maxX - x > line.rect.height) {
            lines.push(line.slice(x, line.rect.maxX));
          }

          return lines;
        }

        /**
         * Finds the intersections between a glyph path and an underline rectangle.
         * It models each contour of the path a straight line, and returns a range
         * containing the leftmost and rightmost intersection points, if any.
         */

      }, {
        key: 'findPathIntersections',
        value: function findPathIntersections(path, rect) {
          var sx = 0;
          var sy = 0;
          var cx = 0;
          var cy = 0;
          var px = 0;
          var py = 0;
          var range = new Range(Infinity, -Infinity);
          var y1 = rect.y;
          var y2 = rect.maxY;
          var dialation = Math.ceil(rect.height);

          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = path.commands[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _ref5 = _step5.value;
              var command = _ref5.command,
                  args = _ref5.args;

              switch (command) {
                case 'moveTo':
                  sx = cx = args[0];
                  sy = cy = args[1];
                  continue;

                case 'lineTo':
                  px = args[0];
                  py = args[1];
                  break;

                case 'quadraticCurveTo':
                  px = args[2];
                  py = args[3];
                  break;

                case 'bezierCurveTo':
                  px = args[4];
                  py = args[5];
                  break;

                case 'closePath':
                  px = sx;
                  py = sy;
                  break;

                default:
                  break;
              }

              this.findIntersectionPoint(y1, cx, cy, px, py, range);
              this.findIntersectionPoint(y2, cx, cy, px, py, range);

              if (cy >= y1 && cy <= y2 || cy <= y1 && cy >= y2) {
                range.extend(cx);
              }

              cx = px;
              cy = py;
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          if (range.start < range.end) {
            range.start -= dialation;
            range.end += dialation;
            return range;
          }

          return null;
        }
      }, {
        key: 'findIntersectionPoint',
        value: function findIntersectionPoint(y, x1, y1, x2, y2, range) {
          if (y1 < y && y2 > y || y1 > y && y2 < y) {
            var x = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
            range.extend(x);
          }
        }
      }]);

      return TextDecorationEngine;
    }();
  };
};