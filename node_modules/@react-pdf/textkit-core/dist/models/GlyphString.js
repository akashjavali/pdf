'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _unicodeProperties = require('@react-pdf/unicode-properties');

var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://www.w3.org/TR/css-text-3/#hanging-punctuation
var HANGING_PUNCTUATION_START_CATEGORIES = new Set(['Ps', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CATEGORIES = new Set(['Pe', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CODEPOINTS = new Set([0x002c, // COMMA
0x002e, // FULL STOP
0x060c, // ARABIC COMMA
0x06d4, // ARABIC FULL STOP
0x3001, // IDEOGRAPHIC COMMA
0x3002, // IDEOGRAPHIC FULL STOP
0xff0c, // FULLWIDTH COMMA
0xff0e, // FULLWIDTH FULL STOP
0xfe50, // SMALL COMMA
0xfe51, // SMALL IDEOGRAPHIC COMMA
0xfe52, // SMALL FULL STOP
0xff61, // HALFWIDTH IDEOGRAPHIC FULL STOP
0xff64, // HALFWIDTH IDEOGRAPHIC COMMA
0x002d // HYPHEN
]);

var GlyphString = function () {
  function GlyphString(string, glyphRuns, start, end) {
    _classCallCheck(this, GlyphString);

    this.string = string;
    this._glyphRuns = glyphRuns;
    this.start = start || 0;
    this._end = end;
    this._glyphRunsCache = null;
    this._glyphRunsCacheEnd = null;
  }

  _createClass(GlyphString, [{
    key: 'slice',
    value: function slice(start, end) {
      var stringStart = this.stringIndexForGlyphIndex(start);
      var stringEnd = this.stringIndexForGlyphIndex(end);

      return new GlyphString(this.string.slice(stringStart, stringEnd), this._glyphRuns, start + this.start, end + this.start);
    }
  }, {
    key: 'runIndexAtGlyphIndex',
    value: function runIndexAtGlyphIndex(index) {
      index += this.start;
      var count = 0;

      for (var i = 0; i < this._glyphRuns.length; i++) {
        var run = this._glyphRuns[i];

        if (count <= index && index < count + run.glyphs.length) {
          return i;
        }

        count += run.glyphs.length;
      }

      return this._glyphRuns.length - 1;
    }
  }, {
    key: 'runAtGlyphIndex',
    value: function runAtGlyphIndex(index) {
      index += this.start;

      for (var i = 0; i < this.glyphRuns.length; i++) {
        var run = this.glyphRuns[i];

        if (run.start <= index && run.end > index) {
          return run;
        }
      }

      return this.glyphRuns[this.glyphRuns.length - 1];
    }
  }, {
    key: 'runIndexAtStringIndex',
    value: function runIndexAtStringIndex(index) {
      var offset = 0;

      for (var i = 0; i < this.glyphRuns.length; i++) {
        var run = this.glyphRuns[i];

        if (offset + run.stringStart <= index && offset + run.stringEnd >= index) {
          return i;
        }

        offset += run.stringEnd;
      }

      return this._glyphRuns.length - 1;
    }
  }, {
    key: 'runAtStringIndex',
    value: function runAtStringIndex(index) {
      return this.glyphRuns[this.runIndexAtStringIndex(index)];
    }
  }, {
    key: 'glyphAtIndex',
    value: function glyphAtIndex(index) {
      var run = this.runAtGlyphIndex(index);
      return run.glyphs[this.start + index - run.start];
    }
  }, {
    key: 'positionAtIndex',
    value: function positionAtIndex(index) {
      var run = void 0;
      var count = 0;

      for (var i = 0; i < this.glyphRuns.length; i++) {
        run = this.glyphRuns[i];

        if (count <= index && index < count + run.positions.length) {
          return run.positions[index - count];
        }

        count += run.positions.length;
      }

      return run.positions[run.positions.length - 1];
    }
  }, {
    key: 'getGlyphWidth',
    value: function getGlyphWidth(index) {
      return this.positionAtIndex(index).xAdvance;
    }
  }, {
    key: 'glyphIndexAtOffset',
    value: function glyphIndexAtOffset(width) {
      var offset = 0;
      var index = 0;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.glyphRuns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var run = _step.value;

          if (offset + run.advanceWidth > width) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = run.positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var position = _step2.value;

                var w = position.xAdvance;
                if (offset + w > width) {
                  return index;
                }

                offset += w;
                index++;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else {
            offset += run.advanceWidth;
            index += run.glyphs.length;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return index;
    }
  }, {
    key: 'stringIndexForGlyphIndex',
    value: function stringIndexForGlyphIndex(index) {
      var run = void 0;
      var count = 0;
      var offset = 0;

      for (var i = 0; i < this.glyphRuns.length; i++) {
        run = this.glyphRuns[i];

        if (offset <= index && offset + run.length > index) {
          return count + run.stringIndices[index + this.start - run.start];
        }

        offset += run.length;
        count += run.glyphIndices.length;
      }

      return count;
    }
  }, {
    key: 'glyphIndexForStringIndex',
    value: function glyphIndexForStringIndex(index) {
      var run = void 0;
      var count = 0;
      var offset = 0;

      for (var i = 0; i < this.glyphRuns.length; i++) {
        run = this.glyphRuns[i];

        if (offset <= index && index < offset + run.stringEnd + 1) {
          return count + run.glyphIndices[index - offset];
        }

        count += run.glyphs.length;
        offset += run.stringEnd + 1;
      }

      return offset;
    }
  }, {
    key: 'codePointAtGlyphIndex',
    value: function codePointAtGlyphIndex(glyphIndex) {
      return this.string.codePointAt(this.stringIndexForGlyphIndex(glyphIndex));
    }
  }, {
    key: 'charAtGlyphIndex',
    value: function charAtGlyphIndex(glyphIndex) {
      return this.string.charAt(this.stringIndexForGlyphIndex(glyphIndex));
    }
  }, {
    key: 'offsetAtGlyphIndex',
    value: function offsetAtGlyphIndex(glyphIndex) {
      var offset = 0;
      var count = glyphIndex;

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.glyphRuns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var run = _step3.value;

          for (var i = 0; i < run.glyphs.length; i++) {
            if (count === 0) {
              return offset;
            }

            offset += run.positions[i].xAdvance;
            count -= 1;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return offset;
    }
  }, {
    key: 'indexOf',
    value: function indexOf(string) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var stringIndex = this.stringIndexForGlyphIndex(index);
      var nextIndex = this.string.indexOf(string, stringIndex);

      if (nextIndex === -1) {
        return -1;
      }

      return this.glyphIndexForStringIndex(nextIndex);
    }
  }, {
    key: 'getUnicodeCategory',
    value: function getUnicodeCategory(index) {
      var codePoint = this.codePointAtGlyphIndex(index);
      return codePoint ? _unicodeProperties2.default.getCategory(codePoint) : null;
    }
  }, {
    key: 'isWhiteSpace',
    value: function isWhiteSpace(index) {
      var codePoint = this.codePointAtGlyphIndex(index);
      return codePoint ? _unicodeProperties2.default.isWhiteSpace(codePoint) : false;
    }
  }, {
    key: 'isHangingPunctuationStart',
    value: function isHangingPunctuationStart(index) {
      return HANGING_PUNCTUATION_START_CATEGORIES.has(this.getUnicodeCategory(index));
    }
  }, {
    key: 'isHangingPunctuationEnd',
    value: function isHangingPunctuationEnd(index) {
      return HANGING_PUNCTUATION_END_CATEGORIES.has(this.getUnicodeCategory(index)) || HANGING_PUNCTUATION_END_CODEPOINTS.has(this.codePointAtGlyphIndex(index));
    }
  }, {
    key: 'insertGlyph',
    value: function insertGlyph(index, codePoint) {
      var runIndex = this.runIndexAtGlyphIndex(index);
      var run = this._glyphRuns[runIndex];
      var _run$attributes = run.attributes,
          font = _run$attributes.font,
          fontSize = _run$attributes.fontSize;

      var glyph = run.attributes.font.glyphForCodePoint(codePoint);
      var scale = fontSize / font.unitsPerEm;
      var glyphIndex = this.start + index - run.start;

      if (this._end) {
        this._end += 1;
      }

      run.glyphs.splice(glyphIndex, 0, glyph);
      run.stringIndices.splice(glyphIndex, 0, run.stringIndices[glyphIndex]);

      for (var i = 0; i < run.glyphIndices.length; i++) {
        if (run.glyphIndices[i] >= glyphIndex) {
          run.glyphIndices[i] += 1;
        }
      }

      run.positions.splice(glyphIndex, 0, {
        xAdvance: glyph.advanceWidth * scale,
        yAdvance: 0,
        xOffset: 0,
        yOffset: run.attributes.yOffset * font.unitsPerEm
      });

      run.end += 1;

      for (var _i = runIndex + 1; _i < this._glyphRuns.length; _i++) {
        this._glyphRuns[_i].start += 1;
        this._glyphRuns[_i].end += 1;
      }

      this._glyphRunsCache = null;
    }
  }, {
    key: 'deleteGlyph',
    value: function deleteGlyph(index) {
      if (index < 0 || index >= this.length) {
        return;
      }

      var runIndex = this.runIndexAtGlyphIndex(index);
      var run = this._glyphRuns[runIndex];
      var glyphIndex = this.start + index - run.start;

      run.glyphs.splice(glyphIndex, 1);
      run.positions.splice(glyphIndex, 1);
      run.stringIndices.splice(glyphIndex, 1);

      for (var i = 0; i < run.glyphIndices.length; i++) {
        if (run.glyphIndices[i] >= glyphIndex) {
          run.glyphIndices[i] -= 1;
        }
      }

      run.end--;

      for (var _i2 = runIndex + 1; _i2 < this._glyphRuns.length; _i2++) {
        this._glyphRuns[_i2].start--;
        this._glyphRuns[_i2].end--;
      }

      this._glyphRunsCache = null;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      var x, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, run, i;

      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              x = 0;
              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context.prev = 4;
              _iterator4 = this.glyphRuns[Symbol.iterator]();

            case 6:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                _context.next = 19;
                break;
              }

              run = _step4.value;
              i = 0;

            case 9:
              if (!(i < run.glyphs.length)) {
                _context.next = 16;
                break;
              }

              _context.next = 12;
              return {
                glyph: run.glyphs[i],
                position: run.positions[i],
                run: run,
                x: x,
                index: run.start + i
              };

            case 12:

              x += run.positions[i].xAdvance;

            case 13:
              i++;
              _context.next = 9;
              break;

            case 16:
              _iteratorNormalCompletion4 = true;
              _context.next = 6;
              break;

            case 19:
              _context.next = 25;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context['catch'](4);
              _didIteratorError4 = true;
              _iteratorError4 = _context.t0;

            case 25:
              _context.prev = 25;
              _context.prev = 26;

              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }

            case 28:
              _context.prev = 28;

              if (!_didIteratorError4) {
                _context.next = 31;
                break;
              }

              throw _iteratorError4;

            case 31:
              return _context.finish(28);

            case 32:
              return _context.finish(25);

            case 33:
            case 'end':
              return _context.stop();
          }
        }
      }, value, this, [[4, 21, 25, 33], [26,, 28, 32]]);
    })
  }, {
    key: 'end',
    get: function get() {
      if (this._glyphRuns.length === 0) {
        return 0;
      }

      var glyphEnd = this._glyphRuns[this._glyphRuns.length - 1].end;

      if (this._end) {
        return Math.min(this._end, glyphEnd);
      }

      return this._glyphRuns.length > 0 ? glyphEnd : 0;
    }
  }, {
    key: 'length',
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: 'advanceWidth',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return acc + run.advanceWidth;
      }, 0);
    }
  }, {
    key: 'height',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.height);
      }, 0);
    }
  }, {
    key: 'ascent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.ascent);
      }, 0);
    }
  }, {
    key: 'descent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.min(acc, run.descent);
      }, 0);
    }
  }, {
    key: 'glyphRuns',
    get: function get() {
      if (this._glyphRunsCache && this._glyphRunsCacheEnd === this.end) {
        return this._glyphRunsCache;
      }

      if (this._glyphRuns.length === 0) {
        this._glyphRunsCache = [];
        this._glyphRunsCacheEnd = this.end;
        return [];
      }

      var startRunIndex = this.runIndexAtGlyphIndex(0);
      var endRunIndex = this.runIndexAtGlyphIndex(this.length);
      var startRun = this._glyphRuns[startRunIndex];
      var endRun = this._glyphRuns[endRunIndex];
      var runs = [];

      runs.push(startRun.slice(this.start - startRun.start, this.end - startRun.start));

      if (endRunIndex !== startRunIndex) {
        runs.push.apply(runs, _toConsumableArray(this._glyphRuns.slice(startRunIndex + 1, endRunIndex)));

        if (this.end - endRun.start !== 0) {
          runs.push(endRun.slice(0, this.end - endRun.start));
        }
      }

      this._glyphRunsCache = runs;
      this._glyphRunsCacheEnd = this.end;
      return runs;
    }
  }]);

  return GlyphString;
}();

exports.default = GlyphString;