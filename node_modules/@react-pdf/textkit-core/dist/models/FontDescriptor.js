'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FONT_WEIGHTS = {
  thin: 100,
  ultralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  ultrabold: 800,
  heavy: 900
};

var FONT_WIDTHS = {
  ultracondensed: 1,
  extracondensed: 2,
  condensed: 3,
  semicondensed: 4,
  normal: 5,
  semiexpanded: 6,
  expanded: 7,
  extraexpanded: 8,
  ultraexpanded: 9
};

function parseFont(font) {
  // When we pass a fontkit TTFFont directly to texkit
  if ((typeof font === 'undefined' ? 'undefined' : _typeof(font)) === 'object') {
    return {
      family: font.familyName,
      postscriptName: font.postscriptName
    };
  }

  if (typeof font !== 'string') {
    return {};
  }

  var parts = font.match(/(.+\.(?:ttf|otf|ttc|dfont|woff|woff2))(?:#(.+))$/);
  if (parts) {
    return {
      path: parts[1],
      postscriptName: parts[2]
    };
  }

  return { family: font };
}

function getFontWeight(weight) {
  if (typeof weight === 'number') {
    return Math.max(100, Math.min(900, Math.floor(weight / 100) * 100));
  }

  if (typeof weight === 'string') {
    return FONT_WEIGHTS[weight.toLowerCase().replace(/-/g, '')];
  }

  return null;
}

function getFontWidth(width) {
  if (typeof width === 'number') {
    return Math.max(1, Math.min(9, width));
  }

  if (typeof width === 'string') {
    return FONT_WIDTHS[width.toLowerCase().replace(/-/g, '')];
  }

  return null;
}

var FontDescriptor = function () {
  function FontDescriptor() {
    var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FontDescriptor);

    this.path = attributes.path;
    this.postscriptName = attributes.postscriptName;
    this.family = attributes.family;
    this.style = attributes.style;
    this.weight = attributes.weight;
    this.width = attributes.width;
    this.italic = attributes.italic;
    this.monospace = attributes.monospace;
  }

  _createClass(FontDescriptor, null, [{
    key: 'fromAttributes',
    value: function fromAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (attributes.fontDescriptor) {
        return new FontDescriptor(attributes.fontDescriptor);
      }

      var font = parseFont(attributes.font || 'Helvetica');
      return new FontDescriptor({
        path: font.path,
        postscriptName: attributes.fontPostscriptName || font.postscriptName,
        family: attributes.fontFamily || font.family,
        style: attributes.fontStyle,
        weight: getFontWeight(attributes.fontWeight) || (attributes.bold ? FONT_WEIGHTS.bold : null),
        width: getFontWidth(attributes.fontWidth),
        italic: attributes.italic,
        monospace: attributes.monospace
      });
    }
  }]);

  return FontDescriptor;
}();

exports.default = FontDescriptor;