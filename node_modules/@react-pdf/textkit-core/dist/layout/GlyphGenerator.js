'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GlyphRun = require('../models/GlyphRun');

var _GlyphRun2 = _interopRequireDefault(_GlyphRun);

var _GlyphString = require('../models/GlyphString');

var _GlyphString2 = _interopRequireDefault(_GlyphString);

var _Run = require('../models/Run');

var _Run2 = _interopRequireDefault(_Run);

var _RunStyle = require('../models/RunStyle');

var _RunStyle2 = _interopRequireDefault(_RunStyle);

var _flattenRuns = require('./flattenRuns');

var _flattenRuns2 = _interopRequireDefault(_flattenRuns);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A GlyphGenerator is responsible for mapping characters in
 * an AttributedString to glyphs in a GlyphString. It resolves
 * style attributes such as the font and Unicode script and
 * directionality properties, and creates GlyphRuns using fontkit.
 */
var GlyphGenerator = function () {
  function GlyphGenerator() {
    var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GlyphGenerator);

    this.resolvers = [engines.fontSubstitutionEngine, engines.scriptItemizer];
  }

  _createClass(GlyphGenerator, [{
    key: 'generateGlyphs',
    value: function generateGlyphs(attributedString) {
      var _this = this;

      // Resolve runs
      var runs = this.resolveRuns(attributedString);

      // Generate glyphs
      var glyphIndex = 0;
      var glyphRuns = runs.map(function (run) {
        var str = attributedString.string.slice(run.start, run.end);
        var glyphRun = run.attributes.font.layout(str, run.attributes.features, run.attributes.script);
        var end = glyphIndex + glyphRun.glyphs.length;
        var glyphIndices = _this.resolveGlyphIndices(str, glyphRun.stringIndices);

        var res = new _GlyphRun2.default(glyphIndex, end, run.attributes, glyphRun.glyphs, glyphRun.positions, glyphRun.stringIndices, glyphIndices);

        _this.resolveAttachments(res);
        _this.resolveYOffset(res);

        glyphIndex = end;
        return res;
      });

      return new _GlyphString2.default(attributedString.string, glyphRuns);
    }
  }, {
    key: 'resolveGlyphIndices',
    value: function resolveGlyphIndices(string, stringIndices) {
      var glyphIndices = [];

      for (var i = 0; i < string.length; i++) {
        for (var j = 0; j < stringIndices.length; j++) {
          if (stringIndices[j] >= i) {
            glyphIndices[i] = j;
            break;
          }

          glyphIndices[i] = undefined;
        }
      }

      var lastValue = glyphIndices[glyphIndices.length - 1];
      for (var _i = glyphIndices.length - 1; _i >= 0; _i--) {
        if (glyphIndices[_i] === undefined) {
          glyphIndices[_i] = lastValue;
        } else {
          lastValue = glyphIndices[_i];
        }
      }

      lastValue = glyphIndices[0];
      for (var _i2 = 0; _i2 < glyphIndices.length; _i2++) {
        if (glyphIndices[_i2] === undefined) {
          glyphIndices[_i2] = lastValue;
        } else {
          lastValue = glyphIndices[_i2];
        }
      }

      return glyphIndices;
    }
  }, {
    key: 'resolveRuns',
    value: function resolveRuns(attributedString) {
      // Map attributes to RunStyle objects
      var r = attributedString.runs.map(function (run) {
        return new _Run2.default(run.start, run.end, new _RunStyle2.default(run.attributes));
      });

      // Resolve run ranges and additional attributes
      var runs = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.resolvers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var resolver = _step.value;

          var resolved = resolver.getRuns(attributedString.string, r);
          runs.push.apply(runs, _toConsumableArray(resolved));
        }

        // Ignore resolved properties
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var styles = attributedString.runs.map(function (run) {
        var attrs = Object.assign({}, run.attributes);
        delete attrs.font;
        delete attrs.fontDescriptor;
        return new _Run2.default(run.start, run.end, attrs);
      });

      // Flatten runs
      var resolvedRuns = (0, _flattenRuns2.default)([].concat(_toConsumableArray(styles), runs));
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = resolvedRuns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var run = _step2.value;

          run.attributes = new _RunStyle2.default(run.attributes);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return resolvedRuns;
    }
  }, {
    key: 'resolveAttachments',
    value: function resolveAttachments(glyphRun) {
      var _glyphRun$attributes = glyphRun.attributes,
          font = _glyphRun$attributes.font,
          attachment = _glyphRun$attributes.attachment;


      if (!attachment) {
        return;
      }

      var objectReplacement = font.glyphForCodePoint(0xfffc);

      for (var i = 0; i < glyphRun.length; i++) {
        var glyph = glyphRun.glyphs[i];
        var position = glyphRun.positions[i];

        if (glyph === objectReplacement) {
          position.xAdvance = attachment.width;
        }
      }
    }
  }, {
    key: 'resolveYOffset',
    value: function resolveYOffset(glyphRun) {
      var _glyphRun$attributes2 = glyphRun.attributes,
          font = _glyphRun$attributes2.font,
          yOffset = _glyphRun$attributes2.yOffset;


      if (!yOffset) {
        return;
      }

      for (var i = 0; i < glyphRun.length; i++) {
        glyphRun.positions[i].yOffset += yOffset * font.unitsPerEm;
      }
    }
  }]);

  return GlyphGenerator;
}();

exports.default = GlyphGenerator;