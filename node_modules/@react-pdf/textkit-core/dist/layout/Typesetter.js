'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LineFragment = require('../models/LineFragment');

var _LineFragment2 = _interopRequireDefault(_LineFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ALIGNMENT_FACTORS = {
  left: 0,
  center: 0.5,
  right: 1,
  justify: 0
};

/**
 * A Typesetter performs glyph line layout, including line breaking,
 * hyphenation, justification, truncation, hanging punctuation,
 * and text decoration. It uses several underlying objects to perform
 * these tasks, which could be overridden in order to customize the
 * typesetter's behavior.
 */

var Typesetter = function () {
  function Typesetter() {
    var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Typesetter);

    this.lineBreaker = engines.lineBreaker;
    this.lineFragmentGenerator = engines.lineFragmentGenerator;
    this.justificationEngine = engines.justificationEngine;
    this.truncationEngine = engines.truncationEngine;
    this.decorationEngine = engines.decorationEngine;
    this.tabEngine = engines.tabEngine;
  }

  _createClass(Typesetter, [{
    key: 'layoutLineFragments',
    value: function layoutLineFragments(lineRect, glyphString, container, paragraphStyle) {
      // Guess the line height using the full line before intersecting with the container.
      lineRect.height = glyphString.slice(0, glyphString.glyphIndexAtOffset(lineRect.width)).height;

      // Generate line fragment rectangles by intersecting with the container.
      var fragmentRects = this.lineFragmentGenerator.generateFragments(lineRect, container);

      if (fragmentRects.length === 0) {
        return [];
      }

      var pos = 0;
      var lineFragments = [];
      var lineHeight = paragraphStyle.lineHeight;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = fragmentRects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fragmentRect = _step.value;

          var line = glyphString.slice(pos, glyphString.length);

          if (this.tabEngine) {
            this.tabEngine.processLineFragment(line, container);
          }

          var bk = this.lineBreaker.suggestLineBreak(line, fragmentRect.width, paragraphStyle);

          if (bk) {
            bk.position += pos;

            var lineFragment = new _LineFragment2.default(fragmentRect, glyphString.slice(pos, bk.position));

            lineFragments.push(lineFragment);
            lineHeight = Math.max(lineHeight, lineFragment.height);

            pos = bk.position;
            if (pos >= glyphString.length) {
              break;
            }
          }
        }

        // Update the fragments on this line with the computed line height
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (lineHeight !== 0) {
        lineRect.height = lineHeight;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = lineFragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fragment = _step2.value;

          fragment.rect.height = lineHeight;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return lineFragments;
    }
  }, {
    key: 'finalizeLineFragment',
    value: function finalizeLineFragment(lineFragment, paragraphStyle, isLastFragment, isTruncated) {
      var align = isLastFragment && !isTruncated ? paragraphStyle.alignLastLine : paragraphStyle.align;

      if (isLastFragment && isTruncated && paragraphStyle.truncationMode) {
        this.truncationEngine.truncate(lineFragment, paragraphStyle.truncationMode);
      }

      this.adjustLineFragmentRectangle(lineFragment, paragraphStyle, align);

      if (align === 'justify' || lineFragment.advanceWidth > lineFragment.rect.width) {
        this.justificationEngine.justify(lineFragment, {
          factor: paragraphStyle.justificationFactor
        });
      }

      this.decorationEngine.createDecorationLines(lineFragment);
    }
  }, {
    key: 'adjustLineFragmentRectangle',
    value: function adjustLineFragmentRectangle(lineFragment, paragraphStyle, align) {
      var start = 0;
      var end = lineFragment.length;

      // Ignore whitespace at the start and end of a line for alignment
      while (lineFragment.isWhiteSpace(start)) {
        lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);
      }

      while (lineFragment.isWhiteSpace(end - 1)) {
        lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);
      }

      // Adjust line rect for hanging punctuation
      if (paragraphStyle.hangingPunctuation) {
        if (align === 'left' || align === 'justify') {
          if (lineFragment.isHangingPunctuationStart(start)) {
            lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);
          }
        }

        if (align === 'right' || align === 'justify') {
          if (lineFragment.isHangingPunctuationEnd(end - 1)) {
            lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);
          }
        }
      }

      lineFragment.rect.x -= lineFragment.overflowLeft;
      lineFragment.rect.width += lineFragment.overflowLeft + lineFragment.overflowRight;

      // Adjust line offset for alignment
      var remainingWidth = lineFragment.rect.width - lineFragment.advanceWidth;
      lineFragment.rect.x += remainingWidth * ALIGNMENT_FACTORS[align];
    }
  }]);

  return Typesetter;
}();

exports.default = Typesetter;