'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ParagraphStyle = require('../models/ParagraphStyle');

var _ParagraphStyle2 = _interopRequireDefault(_ParagraphStyle);

var _Rect = require('../geom/Rect');

var _Rect2 = _interopRequireDefault(_Rect);

var _Block = require('../models/Block');

var _Block2 = _interopRequireDefault(_Block);

var _GlyphGenerator = require('./GlyphGenerator');

var _GlyphGenerator2 = _interopRequireDefault(_GlyphGenerator);

var _Typesetter = require('./Typesetter');

var _Typesetter2 = _interopRequireDefault(_Typesetter);

var _injectEngines = require('./injectEngines');

var _injectEngines2 = _interopRequireDefault(_injectEngines);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 1. split into paragraphs
// 2. get bidi runs and paragraph direction
// 3. font substitution - map to resolved font runs
// 4. script itemization
// 5. font shaping - text to glyphs
// 6. line breaking
// 7. bidi reordering
// 8. justification

// 1. get a list of rectangles by intersecting path, line, and exclusion paths
// 2. perform line breaking to get acceptable break points for each fragment
// 3. ellipsize line if necessary
// 4. bidi reordering
// 5. justification

/**
 * A LayoutEngine is the main object that performs text layout.
 * It accepts an AttributedString and a list of Container objects
 * to layout text into, and uses several helper objects to perform
 * various layout tasks. These objects can be overridden to customize
 * layout behavior.
 */
var LayoutEngine = function () {
  function LayoutEngine(engines) {
    _classCallCheck(this, LayoutEngine);

    var injectedEngines = (0, _injectEngines2.default)(engines);
    this.glyphGenerator = new _GlyphGenerator2.default(injectedEngines);
    this.typesetter = new _Typesetter2.default(injectedEngines);
  }

  _createClass(LayoutEngine, [{
    key: 'layout',
    value: function layout(attributedString, containers) {
      var start = 0;

      for (var i = 0; i < containers.length && start < attributedString.length; i++) {
        var container = containers[i];
        var bbox = container.bbox,
            columns = container.columns,
            columnGap = container.columnGap;

        var isLastContainer = i === containers.length - 1;
        var columnWidth = (bbox.width - columnGap * (columns - 1)) / columns;
        var rect = new _Rect2.default(bbox.minX, bbox.minY, columnWidth, bbox.height);

        for (var j = 0; j < container.columns && start < attributedString.length; j++) {
          start = this.layoutColumn(attributedString, start, container, rect.copy(), isLastContainer);
          rect.x += columnWidth + container.columnGap;
        }
      }
    }
  }, {
    key: 'layoutColumn',
    value: function layoutColumn(attributedString, start, container, rect, isLastContainer) {
      while (start < attributedString.length && rect.height > 0) {
        var next = attributedString.string.indexOf('\n', start);
        if (next === -1) {
          next = attributedString.string.length;
        }

        var paragraph = attributedString.slice(start, next);
        var block = this.layoutParagraph(paragraph, container, rect, isLastContainer);
        var paragraphHeight = block.bbox.height + block.style.paragraphSpacing;

        container.blocks.push(block);

        rect.y += paragraphHeight;
        rect.height -= paragraphHeight;
        start += paragraph.length;

        if (attributedString.string[start] === '\n') {
          start++;
        }

        // If entire paragraph did not fit, move on to the next column or container.
        if (start < next) {
          break;
        }
      }

      return start;
    }
  }, {
    key: 'layoutParagraph',
    value: function layoutParagraph(attributedString, container, rect, isLastContainer) {
      var _this = this;

      var glyphString = this.glyphGenerator.generateGlyphs(attributedString);
      var paragraphStyle = new _ParagraphStyle2.default(attributedString.runs[0].attributes);
      var marginLeft = paragraphStyle.marginLeft,
          marginRight = paragraphStyle.marginRight,
          indent = paragraphStyle.indent,
          maxLines = paragraphStyle.maxLines,
          lineSpacing = paragraphStyle.lineSpacing;


      var lineRect = new _Rect2.default(rect.x + marginLeft + indent, rect.y, rect.width - marginLeft - indent - marginRight, glyphString.height);

      var pos = 0;
      var lines = 0;
      var firstLine = true;
      var fragments = [];

      while (lineRect.y < rect.maxY && pos < glyphString.length && lines < maxLines) {
        var lineString = glyphString.slice(pos, glyphString.length);
        var lineFragments = this.typesetter.layoutLineFragments(lineRect, lineString, container, paragraphStyle);

        lineRect.y += lineRect.height + lineSpacing;

        if (lineFragments.length > 0) {
          fragments.push.apply(fragments, _toConsumableArray(lineFragments));
          pos = lineFragments[lineFragments.length - 1].end;
          lines++;

          if (firstLine) {
            lineRect.x -= indent;
            lineRect.width += indent;
            firstLine = false;
          }
        }
      }

      // Add empty line fragment for empty glyph strings
      if (glyphString.length === 0) {
        var newLineFragment = this.typesetter.layoutLineFragments(lineRect, glyphString, container, paragraphStyle);

        fragments.push.apply(fragments, _toConsumableArray(newLineFragment));
      }

      var isTruncated = isLastContainer && pos < glyphString.length;
      fragments.forEach(function (fragment, i) {
        var isLastFragment = i === fragments.length - 1 && pos === glyphString.length;

        _this.typesetter.finalizeLineFragment(fragment, paragraphStyle, isLastFragment, isTruncated);
      });

      return new _Block2.default(fragments, paragraphStyle);
    }
  }]);

  return LayoutEngine;
}();

exports.default = LayoutEngine;